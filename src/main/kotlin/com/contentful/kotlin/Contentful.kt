/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.contentful.kotlin

import com.contentful.kotlin.annotations.ContentfulField
import com.contentful.kotlin.annotations.ContentfulSystemField
import com.contentful.kotlin.annotations.ContentfulType
import com.contentful.kotlin.models.*
import retrofit2.Call
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.GET
import retrofit2.http.Header
import retrofit2.http.Path
import retrofit2.http.QueryMap
import java.lang.System
import java.lang.reflect.Field
import com.contentful.kotlin.models.Array as Arr

class Contentful(
    spaceId: String,
    token: String,
    environmentId: String = "master",
    preview: Boolean = false,
    host: String? = null
) {
    @PublishedApi
    internal val i: Implementation = Implementation(
        spaceId,
        token,
        environmentId,
        preview,
        host
    )

    inline fun <reified Entity : Resource> fetchAll(generator: Filter.() -> Unit): Result<Arr<Entity>> =
        i.fetchAll(i.findAllCustomTypes(Entity::class.java), generator)

    inline fun <reified Entity : Resource> fetchAll(filter: MutableMap<String, Any> = mutableMapOf()): Result<Arr<Entity>> =
        i.fetchAll(filter, i.findAllCustomTypes(Entity::class.java))

    inline fun <reified Entity : Resource> fetchOne(id: String): Result<Arr<Entity>> =
        i.fetchOne(id, i.findAllCustomTypes(Entity::class.java))

    fun initialSync(): Result<Sync> = i.initialSync()

    fun sync(syncToken: String): Result<Sync> = i.sync(syncToken)

    fun sync(previous: Sync): Result<Sync> = i.sync(previous)
}

@Suppress("UNCHECKED_CAST")
class Implementation(
    @PublishedApi internal val spaceId: String,
    @PublishedApi internal val token: String,
    @PublishedApi internal val environmentId: String = "master",
    preview: Boolean = false,
    host: String? = null
) {
    @PublishedApi
    internal val service: ContentfulService

    init {
        val retrofit = Retrofit.Builder()
            .baseUrl(getBaseUrl(host, preview))
            .addConverterFactory(GsonConverterFactory.create())
            .build()

        service = retrofit.create(ContentfulService::class.java)
    }

    inline fun <reified Entity : Resource> fetchAll(
        filter: MutableMap<String, Any> = mutableMapOf(),
        customClasses: List<Class<Resource>>
    ): Result<Arr<Entity>> =
        try {
            val response = findCall(Entity::class.java, filter).execute()
            parseRawResult(Entity::class.java, customClasses, response)
        } catch (t: Throwable) {
            Result.fail(t)
        }

    inline fun <reified Entity : Resource> fetchAll(
        customClasses: List<Class<Resource>>,
        filterGenerator: Filter.() -> Unit
    ): Result<Arr<Entity>> {
        val filter = Filter()
        filter.filterGenerator()

        return fetchAll(filter.build(), customClasses)
    }

    inline fun <reified T : Resource> fetchOne(
        id: String,
        customClasses: List<Class<Resource>>
    ): Result<Arr<T>> = fetchAll(customClasses) { id(id) }

    fun initialSync(): Result<Sync> =
        try {
            val response = service.sync(
                "Bearer $token",
                spaceId,
                environmentId,
                mutableMapOf("initial" to true)
            ).execute()
            if (response.isSuccessful) {
                Result.succeed(response.body()!!)
            } else {
                Result.fail(IllegalStateException(formatFailureDescription(response)))
            }
        } catch (t: Throwable) {
            Result.fail(t)
        }


    fun sync(syncToken: String): Result<Sync> =
        try {
            val response = service.sync(
                "Bearer $token",
                spaceId,
                environmentId,
                mutableMapOf("sync_token" to syncToken)
            ).execute()
            if (response.isSuccessful) {
                Result.succeed(response.body()!!)
            } else {
                Result.fail(IllegalStateException(formatFailureDescription(response)))
            }
        } catch (t: Throwable) {
            Result.fail(t)
        }

    fun sync(previous: Sync): Result<Sync> =
        try {
            val response = service.sync(
                "Bearer $token",
                spaceId,
                environmentId,
                mutableMapOf("sync_token" to previous.nextSyncToken())
            ).execute()
            if (response.isSuccessful) {
                Result.succeed(response.body()!!)
            } else {
                Result.fail(
                    IllegalStateException(formatFailureDescription(response))
                )
            }
        } catch (t: Throwable) {
            Result.fail(t)
        }


    private fun getBaseUrl(host: String?, preview: Boolean): String =
        if (host.isNullOrEmpty()) {
            if (preview) "https://preview.contentful.com" else "https://cdn.contentful.com"
        } else {
            host
        }

    public fun <Entity : Resource> parseRawResult(
        clazz: Class<Entity>,
        customClasses: List<Class<Resource>>,
        response: Response<out Arr<out Resource>>
    ): Result<Arr<Entity>> {
        return if (response.isSuccessful) {
            val responseBody = response.body()
            if (responseBody !is Arr) {
                val type = if (responseBody != null) responseBody::class.java.simpleName else null
                val value = responseBody.toString()
                Result.fail(IllegalStateException("Response body is not a Contentful array but of type '$type' and value '$value'."))
            } else {
                parseContentfulResponse(clazz, customClasses, responseBody)
            }
        } else {
            Result.fail(
                IllegalStateException(formatFailureDescription(response))
            )
        }
    }

    private fun <Entity : Resource> parseContentfulResponse(
        clazz: Class<Entity>,
        customClasses: List<Class<Resource>>,
        responseBody: Arr<out Resource>?
    ): Result<Arr<Entity>> {
        val typedResponseBody = responseBody as Arr<Entry>
        val resolved = resolveLinks(typedResponseBody, mutableMapOf())

        val successResult = if (isCustomType(clazz)) {
            customizeResponse(clazz, customClasses, resolved)
        } else {
            resolved
        } as Arr<Entity>

        return Result.succeed(successResult)
    }

    public fun <Entity : Resource> findCall(
        clazz: Class<Entity>,
        filter: MutableMap<String, Any>
    ): Call<out Arr<out Resource>> {
        return when {
            Entry::class.java.isAssignableFrom(clazz) -> service.fetchEntries(
                "Bearer $token",
                spaceId,
                environmentId,
                filter
            )
            Asset::class.java.isAssignableFrom(clazz) -> service.fetchAssets(
                "Bearer $token",
                spaceId,
                environmentId,
                filter
            )
            ContentType::class.java.isAssignableFrom(clazz) -> service.fetchContentTypes(
                "Bearer $token",
                spaceId,
                environmentId,
                filter
            )
            Locale::class.java.isAssignableFrom(clazz) -> service.fetchLocales(
                "Bearer $token",
                spaceId,
                environmentId,
                filter
            )
            else -> service.fetchEntries(
                "Bearer $token",
                spaceId,
                environmentId,
                customizeBody(clazz, filter)
            )
        }
    }

    private fun formatFailureDescription(response: Response<*>) = "\n" +
            "request: ${response.raw().request()}\n" +
            "response:${response.errorBody()?.string()}\n"

    private fun <Entity : Resource> customizeBody(
        clazz: Class<Entity>,
        body: MutableMap<String, Any>
    ): MutableMap<String, Any> {
        val annotation = clazz.getAnnotation(ContentfulType::class.java)

        body["content_type"] = if (annotation is ContentfulType) {
            annotation.contentTypeId
        } else {
            clazz.simpleName.split("$").last().decapitalize()
        }

        body["select"] = fieldsToSelectFilter(clazz.declaredFields)
        return body
    }

    private fun fieldsToSelectFilter(fields: Array<Field>) =
        "sys," + fields.filter { it.getAnnotation(ContentfulSystemField::class.java) == null }
            .joinToString(",") { "fields.${getCustomFieldName(it)}" }

    private fun <Entity : Resource> resolveLinks(
        array: Arr<Entity>,
        resolved: MutableMap<String, Resource>
    ): Arr<Entity> {
        array.items.forEach {
            when (it) {
                is Entry -> resolved["e${it.sys?.id}"] = it
                is Asset -> resolved["a${it.sys?.id}"] = it
            }
        }

        array.includes?.entries?.forEach { resolved["e" + it.sys?.id] = it }
        array.includes?.assets?.forEach { resolved["a" + it.sys?.id] = it }

        resolved.values.forEach { resolve(it, resolved) }
        array.items.forEach { resolve(it, resolved) }

        return array
    }

    @PublishedApi
    internal fun resolve(resource: Resource, resolved: MutableMap<String, Resource>) {
        if (resource !is Entry) return

        for (key in resource.fields.keys) {
            val value = resource.fields[key]

            resource.fields[key] = when {
                isFieldALink(value) -> resolveSingle(value, resolved)
                value is MutableList<*> -> resolveList(value, resolved)
                else -> value
            }
        }
    }

    private fun resolveList(list: MutableList<*>, resolved: MutableMap<String, Resource>) =
        list.map {
            if (isFieldALink(it)) {
                // link found!
                val id = idFromField(it) as String
                val type = linkTypeFromField(it)
                val prefix = type.first().toLowerCase()

                if (resolved.containsKey(prefix + id)) {
                    resolved[prefix + id]
                } else {
                    System.err.println("Could not find id '$id' in response.")
                    it
                }
            } else {
                // no change needed, no link
                it
            }
        }


    private fun resolveSingle(value: Any?, resolved: MutableMap<String, Resource>): Any? {
        val id = idFromField(value) as String
        val type = linkTypeFromField(value)
        val prefix = type.first().toLowerCase()

        return if (resolved.containsKey(prefix + id)) {
            resolved[prefix + id]
        } else {
            System.err.println("Could not find id '$id' in response.")
            value
        }
    }

    private fun isFieldALink(fieldValue: Any?) =
        fieldValue is Map<*, *>
                && fieldValue["sys"] is Map<*, *>
                && (fieldValue["sys"] as Map<*, *>)["type"] == "Link"
                && (fieldValue["sys"] as Map<*, *>)["linkType"] is String
                && listOf("Entry", "Asset").contains((fieldValue["sys"] as Map<*, *>)["linkType"] as String)

    private fun idFromField(fieldValue: Any?) =
        if (fieldValue is Map<*, *>
            && fieldValue["sys"] is Map<*, *>
            && (fieldValue["sys"] as Map<*, *>)["id"] != null
        ) {
            (fieldValue["sys"] as Map<*, *>)["id"]
        } else {
            ""
        }

    private fun linkTypeFromField(fieldValue: Any?) =
        if (fieldValue is Map<*, *>
            && fieldValue["sys"] is Map<*, *>
            && (fieldValue["sys"] as Map<*, *>)["linkType"] != null
        ) {
            (fieldValue["sys"] as Map<*, *>)["linkType"] as String
        } else {
            ""
        }

    private fun <Entity : Resource> customizeResponse(
        clazz: Class<Entity>,
        customClasses: List<Class<Resource>>,
        body: Arr<Entry>
    ): Arr<Entity> {
        val alreadyParsedCustoms = mutableMapOf<String, Any?>()

        return Arr(
            ArraySystem("Entry"),
            body.skip,
            body.total,
            body.limit,
            ArrayList(
                body.items.map {
                    convertEntryToCustom(clazz, customTypeIdToClasses(customClasses), it, alreadyParsedCustoms)
                }
            )
        )
    }

    private fun customTypeIdToClasses(classes: List<Class<Resource>>): Map<String, Class<Resource>> {
        val resultMap = mutableMapOf<String, Class<Resource>>()
        classes.forEach {
            resultMap[getCustomTypeId(it)] = it
        }

        return resultMap
    }

    private fun getCustomTypeId(clazz: Class<Resource>): String {
        val annotation = clazz.getAnnotation(ContentfulType::class.java)
        return if (annotation == null) {
            clazz.simpleName.split("$").last().decapitalize()
        } else {
            if (annotation.contentTypeId.isNotEmpty()) {
                annotation.contentTypeId
            } else {
                clazz.simpleName.split("$").last().decapitalize()
            }
        }
    }

    private fun <Entity : Resource> convertEntryToCustom(
        clazz: Class<Entity>,
        customClasses: Map<String, Class<Resource>>,
        entry: Entry,
        alreadyParsed: MutableMap<String, Any?>
    ): Entity {
        if (alreadyParsed.containsKey(entry.sys!!.id)) {
            return alreadyParsed[entry.sys.id] as Entity
        }

        val newEntity = createEmptyEntity(clazz)

        alreadyParsed[entry.sys.id] = newEntity

        for (newEntityField in clazz.declaredFields) {
            val wasAlreadyWritable = newEntityField.isAccessible
            newEntityField.isAccessible = true

            if (MutableList::class.java.isAssignableFrom(newEntityField.type)) {
                convertCollectionToCustom(newEntityField, newEntity, entry, customClasses, alreadyParsed)
            } else {
                convertSingleFieldToCustom(newEntityField, customClasses, entry, alreadyParsed, newEntity)
            }

            newEntityField.isAccessible = wasAlreadyWritable
        }

        return newEntity
    }

    private fun <T : Resource> convertCollectionToCustom(
        newEntityField: Field,
        newEntity: T,
        entry: Entry,
        customClasses: Map<String, Class<Resource>>,
        alreadyParsed: MutableMap<String, Any?>
    ) {
        // list found
        var list = newEntityField.get(newEntity) as MutableList<Resource>?
        if (list == null) {
            list = mutableListOf()
            newEntityField.set(newEntity, list)
        } else {
            list.clear()
        }

        list.addAll(
            (entry.fields[getCustomFieldName(newEntityField)] as List<Resource>).map {
                if (it is Entry && customClasses.containsKey(it.sys?.contentType?.sys?.id)) {
                    convertEntryToCustom(
                        customClasses[it.sys?.contentType?.sys?.id]!!,
                        customClasses,
                        it,
                        alreadyParsed
                    )
                } else {
                    it
                }
            }
        )
    }

    private fun <T : Resource> convertSingleFieldToCustom(
        newEntityField: Field,
        customClasses: Map<String, Class<Resource>>,
        entry: Entry,
        alreadyParsed: MutableMap<String, Any?>,
        newEntity: T
    ) {
        if (isCustomType(newEntityField.type)) {
            // custom type found, parse it
            val converted =
                convertEntryToCustom(
                    newEntityField.type as Class<Resource>,
                    customClasses,
                    entry.fields[getCustomFieldName(newEntityField)] as Entry,
                    alreadyParsed
                )
            newEntityField.set(newEntity, converted)
        } else {
            // parse Contentful typed fields
            val systemParameter = tryParseToSystemField(entry, newEntityField)
            if (systemParameter != null) {
                val wasAccessible = newEntityField.isAccessible
                newEntityField.isAccessible = true
                newEntityField.set(newEntity, systemParameter)
                newEntityField.isAccessible = wasAccessible
            } else {
                // could not parse it as sys field, try normal field
                newEntityField.set(newEntity, parseToField(entry, newEntityField))
            }
        }
    }

    private fun <T> createEmptyEntity(clazz: Class<T>): T {
        val fields = clazz.declaredFields
        val types = fields.map { it.type }.toTypedArray()
        val values = fields.map {
            try {
                it.type.newInstance()
            } catch (e: InstantiationException) {
                null
            }
        }.toTypedArray()

        return clazz.getConstructor(*types).newInstance(*values)
    }

    private fun isCustomType(fieldType: Class<*>): Boolean {
        return Resource::class.java.isAssignableFrom(fieldType) &&
                !Asset::class.java.isAssignableFrom(fieldType) &&
                !Entry::class.java.isAssignableFrom(fieldType) &&
                !Locale::class.java.isAssignableFrom(fieldType) &&
                !ContentType::class.java.isAssignableFrom(fieldType)
    }

    private fun parseToField(entry: Entry, field: Field): Any? {
        val name = getCustomFieldName(field)

        return if (entry.fields.containsKey(name)) {
            entry.fields[name]
        } else {
            null
        }
    }

    private fun getCustomFieldName(field: Field): String {
        val annotation = field.getAnnotation(ContentfulField::class.java)
        return annotation?.name ?: field.name
    }

    private fun tryParseToSystemField(entry: Entry, field: Field): Any? {
        val systemFieldAnnotation = field.getAnnotation(ContentfulSystemField::class.java) ?: return null

        val name = if (systemFieldAnnotation.name.isNotEmpty()) {
            systemFieldAnnotation.name
        } else {
            field.name
        }

        val sysField = entry.sys!!::class.java.declaredFields.firstOrNull { it.name == name }
        val wasAccessible = sysField?.isAccessible ?: false
        sysField?.isAccessible = true
        val value = sysField?.get(entry.sys)
        sysField?.isAccessible = wasAccessible

        return value
    }

    fun findAllCustomTypes(clazz: Class<*>): List<Class<Resource>> {
        val result = mutableListOf<Class<Resource>>()
        for (field in clazz.declaredFields) {
            if (isCustomType(field.type) && !result.contains(field.type)) {
                result += field.type as Class<Resource>

                val contentfulTypeAnnotation = field.type.getAnnotation(ContentfulType::class.java)
                if (contentfulTypeAnnotation != null) {
                    result.addAll(contentfulTypeAnnotation.connectedModelsClasses.map { it.java as Class<Resource> })
                }
            } else if (Collection::class.java.isAssignableFrom(field.type)) {
                val customElementClazz = this.javaClass.classLoader.loadClass(elementClassFromListField(field))
                val contentfulTypeAnnotation = customElementClazz.getAnnotation(ContentfulType::class.java)
                if (contentfulTypeAnnotation != null) {
                    result.addAll(contentfulTypeAnnotation.connectedModelsClasses.map { it.java as Class<Resource> })
                }

                try {
                    result.add(customElementClazz as Class<Resource>)
                    findAllCustomTypes(customElementClazz).forEach {
                        result += it
                    }
                } catch (e: ClassCastException) {
                    // could not find a list of resources. so ignore it.
                }
            }
        }

        return result
    }

    private fun elementClassFromListField(field: Field): String {
        // HACK! Find the class type of the elements of this list by a string representation:
        val sign = signature(field)
        return sign.substring(
            IntRange(
                sign.lastIndexOf("<") + 2,
                sign.lastIndexOf(">") - 2
            )
        ).replace("/", ".")
    }

    private fun signature(field: Field): String {
        val signature = field.javaClass.getDeclaredField("signature")
        val wasAccessable = signature.isAccessible
        signature.isAccessible = true

        try {
            val sign = signature.get(field) as String
            return sign
        } finally {
            signature.isAccessible = wasAccessable
        }
    }

}

interface ContentfulService {
    @GET("spaces/{spaceId}/environments/{environmentId}/entries")
    fun fetchEntries(
        @Header("Authorization") authorization: String,
        @Path("spaceId") spaceId: String,
        @Path("environmentId") environmentId: String,
        @QueryMap filters: MutableMap<String, Any>
    ): Call<Arr<Entry>>

    @GET("spaces/{spaceId}/environments/{environmentId}/assets")
    fun fetchAssets(
        @Header("Authorization") authorization: String,
        @Path("spaceId") spaceId: String,
        @Path("environmentId") environmentId: String,
        @QueryMap filters: MutableMap<String, Any>
    ): Call<Arr<Asset>>

    @GET("spaces/{spaceId}/environments/{environmentId}/content_types")
    fun fetchContentTypes(
        @Header("Authorization") authorization: String,
        @Path("spaceId") spaceId: String,
        @Path("environmentId") environmentId: String,
        @QueryMap filters: MutableMap<String, Any>
    ): Call<Arr<ContentType>>

    @GET("spaces/{spaceId}/environments/{environmentId}/locales")
    fun fetchLocales(
        @Header("Authorization") authorization: String,
        @Path("spaceId") spaceId: String,
        @Path("environmentId") environmentId: String,
        @QueryMap filters: MutableMap<String, Any>
    ): Call<Arr<Locale>>

    @GET("spaces/{spaceId}/environments/{environmentId}/sync")
    fun sync(
        @Header("Authorization") authorization: String,
        @Path("spaceId") spaceId: String,
        @Path("environmentId") environmentId: String,
        @QueryMap filters: MutableMap<String, Any>
    ): Call<Sync>
}
